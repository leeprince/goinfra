package listnode

/**
 * @Author: prince.lee <leeprince@foxmail.com>
 * @Date:   2023/4/5 23:43
 * @Desc:	合并两个有序链表
 */

/*
将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

https://leetcode.cn/problems/merge-two-sorted-lists/
*/

/*
形象地理解，这个算法的逻辑类似于拉拉链，l1, l2 类似于拉链两侧的锯齿，指针 p 就好像拉链的拉索，将两个有序链表合并；或者说这个过程像蛋白酶合成蛋白质，l1, l2 就好比两条氨基酸，而指针 p 就好像蛋白酶，将氨基酸组合成蛋白质。

代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧，也就是 newListNode 节点。你可以试试，如果不使用 newListNode 虚拟节点，代码会复杂一些，需要额外处理指针 p 为空的情况。而有了 dummy 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性。
	- 什么时候需要用虚拟头结点？
	总结下：当你需要创造一条新链表的时候，可以使用虚拟头结点简化边界情况的处理。比如说，让你把两条有序链表合并成一条新的有序链表，是不是要创造一条新链表？再比你想把一条链表分解成两条链表，是不是也在创造新链表？这些情况都可以使用虚拟头结点简化边界情况的处理。
*/

func MergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
	// 创建一个虚拟头节点，便于处理边界情况
	dummy := &ListNode{Val: 0, Next: nil} // 虚拟头节点
	tail := dummy                         // 尾部指针，初始指向虚拟头节点
	
	// 使用循环遍历两个链表直到至少有一个链表遍历完
	for l1 != nil && l2 != nil {
		// 比较当前节点的值，将值较小的节点链接到结果链表上
		if l1.Val < l2.Val {
			tail.Next = l1 // 连接l1节点
			l1 = l1.Next   // 移动l1指针到下一个节点
		} else {
			tail.Next = l2 // 连接l2节点
			l2 = l2.Next   // 移动l2指针到下一个节点
		}
		tail = tail.Next // 更新结果链表的尾部指针
	}
	
	// 当一个链表遍历完后，将另一个未遍历完的链表剩余部分接到结果链表后面
	if l1 != nil {
		tail.Next = l1 // 若l1还未遍历完，将其余部分接到结果链表
	} else {
		tail.Next = l2 // 若l2还未遍历完，将其余部分接到结果链表
	}
	
	// 返回新链表的实际头部（即虚拟头节点的下一个节点）
	return dummy.Next
}
